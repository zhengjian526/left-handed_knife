---
layout: post
title: 汇编语言学习-王爽版
categories: 汇编语言学习
description: 汇编语言学习-王爽版
keywords: 汇编语言, 指令集, SIMD算子加速
---

# 汇编语言学习

在学习语言的过程中，一些等效的操作，一种语法的效率会比另一种语法高效很多，但程序员很难直观感受到其中的原因。例如C++中，数组通过指针访问要比通过数组索引下标访问的效率高。如果之前没接触过相关的知识，第一反应很难说出原因，但是如果打印一下反汇编代码，可以很清晰的看出，通过指针访问数组的操作指令数要比通过数组下标访问少很多。

这也道出了学习汇编语言的原因，掌握汇编语言，可以便于程序员清晰的了解到语言的某个语法糖或者新特性的底层实现，万变不离其宗。另外就是在一些高性能优化的场景，需要对特定硬件的指令集进行优化加速，同样需要汇编语言。

由于本人此前对汇编语言知之甚少，此文以王爽版《汇编语言》为学习资料，进行各个章节的学习，并进行重点知识总结，虽然该书中用到的8086 CPU比较久远，指令集比较简单，但也正因如此，适合入门学习，也便于以后扩展到更新的CPU上。此外，王爽版本的《汇编语言》也是众多技术博主推荐的入门教材，是国内汇编语言教材为数不多的经典之作。

## 第一章 基础知识

主要介绍了计算机、CPU相关的基本知识，包括存储器，指令、数据和总线等，较为基础，感兴趣的可以迅速浏览一遍。

### 小结

1. 汇编指令是机器指令的助记符，同机器指令一一对应；
2. 每一种CPU都有自己的汇编指令集；
3. CPU可以直接使用的信息在存储器中存放；
4. 在存储器中的指令和数据没有任何区别，都是二进制信息；
5. 存储单元从0开始顺序编号；
6. 一个存储单元可以存储8个bit， 即8位二进制数；
7. 1Byte = 8bit ， 1KB = 1024B， 1MB = 1024KB， 1GB = 1024MB
8. 每个CPU芯片都有许多管脚，这些管脚与总线相连。也可以说，这些管脚引出总线。一个CPU可以引出3中总线的宽度标志了这个CPU的不同方面的性能：
   - 地址总线宽度决定了CPU寻址能力；
   - 数据总线宽度决定了CPU与其他器件进行数据传输时的一次数据传输量；
   - 控制总线的宽度决定了CPU对系统中其他器件的控制能力。

## 第二章 寄存器

1. 8086CPU有4个通用16位寄存器，AX、BX、CX、DX，其中每个寄存器都可以独立当做两个8位寄存器来使用，

   - AX可分为AH和AL；
   - BX可分为BH和BL；
   - CX可分为CH和CL；
   - DX可分为DH和DL

   ![assembly_0001](/images/posts/assembly/assembly_0001.png)

2. 几条汇编指令：

![assembly_0002](/images/posts/assembly/assembly_0002.png)

在进行数据传送或者运算时，要注意指令的两个操作对象的位数应该是一致的，例如：

```assembly
mov ax, bx
mov bx, cx
mov ax, 18H
mov al, 18H
add ax, bx
add ax, 20000
```

以上指令都是正确的。

而：

```assembly
mov ax, bl (在8位寄存器和16位寄存器之间传送数据)
mov bh, ax (在16位寄存器和8位寄存器之间传送数据)
mov al, 20000 (8位寄存器最大可存储值为255的数据)
mov al, 100H (将高于8位的数据加到8位寄存器中) (一个字节为两个16进制位表示)
```

以上都是错误的指令，错误原因是指令的两个操作对象位数不一致。

3. 8086是16位的CPU，16位结构描述了一个CPU具有以下几个方面的结构特性：	
   - 运算器一次最多可以处理16位数据；
   - 寄存器的最大宽度是16位；
   - 寄存器与运算器之间的通路为16位。

### 8086CPU给出物理地址的方法

8086 cpu有20位地址总线，可以传送20位地址，有1MB的寻址能力。但是CPU是16位结构，因此一次只能处理或者传输16位地址。8086CPU采用一种内部使用两个16位地址合成一个20位物理地址。相关部件的逻辑结构如下图：

![assembly_0003](/images/posts/assembly/assembly_0003.png)

地址加法器采用 ` 物理地址 = 段地址x16 + 偏移地址`的方式合成物理地址。例如想要访问地址123C8H的内存单元，地址加法器的工作流程如下：

![assembly_0004](/images/posts/assembly/assembly_0004.png)

**其本质原因是CPU是16位结构，无法存储20位结构的地址，因此需要两个16位，并约定特定的地址计算方式，生成20位的地址。**

### 段的概念

上文中有提到“段地址”，这个名称中包含了”段“的概念，这可能会使人产生误导，认为内存被划分成一个一个的段，每个段有一个段地址。但其实内存并没有分段，段的划分来自于CPU，8086CPU使用 ` 物理地址 = 段地址x16 + 偏移地址`的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。

### 段寄存器以及CS和IP

8086CPU有四个段寄存器：CS、DS、SS和ES。

CS和IP是最关键的两个寄存器，他们指示了要读取指令的地方。CS为代码段寄存器，IP为指令指针寄存器，**在8086PC机上，任意时刻，设CS寄存器中的内容为M，IP中的内容为N，8086CPU将从内存Mx16 + N单元开始，读取一条指令并执行。**

简言之，**8086机中，任意时刻，CPU将CS：IP指向的内容当做指令执行。**

这里便于理解，举例说明读取和执行指令的流程，如不理解，更详细的流程可以参考书籍第二章2.10小结。

![assembly_0005](/images/posts/assembly/assembly_0005.png)

![assembly_0006](/images/posts/assembly/assembly_0006.png)

![assembly_0007](/images/posts/assembly/assembly_0007.png)

![assembly_0008](/images/posts/assembly/assembly_0008.png)

![assembly_0009](/images/posts/assembly/assembly_0009.png)

![assembly_0010](/images/posts/assembly/assembly_0010.png)

8086CPU的工作流程可以简单描述如下：

1. 从CS:IP指向的内存读取指令，读取的指令进入到指令缓冲器；
2. IP = IP + 所读取指令的长度，从而指向下一条指令；
3. 执行指令。转到步骤1，重复这个过程。

### 修改CS、IP指令

8086CPU的大部分寄存器的值，都可以通过mov指令来改变，**mov指令称为传送指令。**但是mov指令不能用于设置CS和IP的值，原因很简单，因为8086CPU没有提供这样的功能。**能改变CS和IP内容的指令成为转移指令**。这里介绍一个最简单的：**jmp指令**。

如果想同时修改CS和IP的值，可用形如“jmp段地址：偏移地址”的指令完成，如：

jmp 2AE3:3, 执行后：CS = 2AE3H， IP=0003H， CPU将从2AE33H处读取指令。

如果只想修改IP寄存器的内容，可以使用形如“jmp 某一合法寄存器”的指令完成， 如：

jmp ax， 指令执行前： ax = 1000H， CS = 2000H， IP = 0003H

​				 指令执行后： ax = 1000H,    CS = 2000H,    IP = 1000H

“jmp 某一合法寄存器”的指令功能为：用寄存器的值修改IP。jmp ax 在含义上等价于 mov  IP， ax。



## 第三章 寄存器（内存访问）

### DS和[address]

8086CPU中有一个DS寄存器，通常存放要访问的数据的段地址，比如我们要读取10000H单元的内容，可以用如下程序进行：

```assembly
mov bx 1000H
mov ds bx
mov al [0]
```

上面3条指令将10000H(1000:0)中的数据读取到al中。

前面提到过，mov指令可完成两种传送：

1. 将数据直接送入寄存器；
2. 将一个寄存器中的内容送入另一个寄存器。

也可以使用mov指令将一个内存单元中的内容送入到寄存器。此时需要指明内存单元的地址，具体格式为： mov  寄存器名， 内存单元地址。

“[···]” 表示一个内存单元， “[···]” 中的0 表示内存单元的偏移地址。这一点和c语言的数组索引下标一致。只有偏移地址无法定位到一个内存单元，定位内存单元还需要段地址。8086CPU自动取DS寄存器中的数据作为内存单元的段地址。

再来看下如何用mov指令从10000H中读取数据。10000H用段地址和偏移地址表示为1000:0， 我们将段地址1000H放入DS，然后用mov al，[0] 完成传送。

**需要说明的是，在上述代码中，我们使用mov bx 1000H和mov ds bx的方式，其中使用到bx进行中转将1000H送入到寄存器DS，那么我们是否可以使用类似mov ds 1000H的方式直接将1000H送入DS。但现实并非如此，8086CPU不支持直接将数据送入到段寄存器的操作，DS是一个段寄存器，所以mov ds 1000H这条指令非法，不支持这个操作的原因源于硬件设计。**

另外：

mov bx 1000H
mov ds bx
mov  [0] al

这几条指令可以实现将al寄存器中的值传送到1000H的内存单元中。

### 小结

1. 字在内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中；

![assembly_0011](/images/posts/assembly/assembly_0011.png)

2. 用mov指令访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中；
3. [address]表示一个偏移地址为address的内存单元；
4. 在内存与寄存器之间传动字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应；
5. mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令。
6. 可以根据自己的推测在debug中实验指令的新格式。








## 参考

- 《汇编语言》 王爽