---
layout: post
title: 汇编语言学习-王爽版
categories: 汇编语言学习
description: 汇编语言学习-王爽版
keywords: 汇编语言, 指令集, SIMD算子加速
---

# 汇编语言学习

在学习语言的过程中，一些等效的操作，一种语法的效率会比另一种语法高效很多，但程序员很难直观感受到其中的原因。例如C++中，数组通过指针访问要比通过数组索引下标访问的效率高。如果之前没接触过相关的知识，第一反应很难说出原因，但是如果打印一下反汇编代码，可以很清晰的看出，通过指针访问数组的操作指令数要比通过数组下标访问少很多。

这也道出了学习汇编语言的原因，掌握汇编语言，可以便于程序员清晰的了解到语言的某个语法糖或者新特性的底层实现，万变不离其宗。另外就是在一些高性能优化的场景，需要对特定硬件的指令集进行优化加速，同样需要汇编语言。

由于本人此前对汇编语言知之甚少，此文以王爽版《汇编语言》为学习资料，进行各个章节的学习，并进行重点知识总结，虽然该书中用到的8086 CPU比较久远，指令集比较简单，但也正因如此，适合入门学习，也便于以后扩展到更新的CPU上。此外，王爽版本的《汇编语言》也是众多技术博主推荐的入门教材，是国内汇编语言教材为数不多的经典之作。

课本中涉及到的实验部分，需要使用DOS Box和debug工具，在WIN10系统上这个工具默认不存在了，具体环境配置和DOSBox安装可以参考：https://blog.csdn.net/plus_re/article/details/60761467 

## 第一章 基础知识

主要介绍了计算机、CPU相关的基本知识，包括存储器，指令、数据和总线等，较为基础，感兴趣的可以迅速浏览一遍。

### 小结

1. 汇编指令是机器指令的助记符，同机器指令一一对应；
2. 每一种CPU都有自己的汇编指令集；
3. CPU可以直接使用的信息在存储器中存放；
4. 在存储器中的指令和数据没有任何区别，都是二进制信息；
5. 存储单元从0开始顺序编号；
6. 一个存储单元可以存储8个bit， 即8位二进制数；
7. 1Byte = 8bit ， 1KB = 1024B， 1MB = 1024KB， 1GB = 1024MB
8. 每个CPU芯片都有许多管脚，这些管脚与总线相连。也可以说，这些管脚引出总线。一个CPU可以引出3中总线的宽度标志了这个CPU的不同方面的性能：
   - 地址总线宽度决定了CPU寻址能力；
   - 数据总线宽度决定了CPU与其他器件进行数据传输时的一次数据传输量；
   - 控制总线的宽度决定了CPU对系统中其他器件的控制能力。

## 第二章 寄存器

1. 8086CPU有4个通用16位寄存器，AX、BX、CX、DX，其中每个寄存器都可以独立当做两个8位寄存器来使用，

   - AX可分为AH和AL；
   - BX可分为BH和BL；
   - CX可分为CH和CL；
   - DX可分为DH和DL

   ![assembly_0001](/images/posts/assembly/assembly_0001.png)

2. 几条汇编指令：

![assembly_0002](/images/posts/assembly/assembly_0002.png)

在进行数据传送或者运算时，要注意指令的两个操作对象的位数应该是一致的，例如：

```assembly
mov ax, bx
mov bx, cx
mov ax, 18H
mov al, 18H
add ax, bx
add ax, 20000
```

以上指令都是正确的。

而：

```assembly
mov ax, bl (在8位寄存器和16位寄存器之间传送数据)
mov bh, ax (在16位寄存器和8位寄存器之间传送数据)
mov al, 20000 (8位寄存器最大可存储值为255的数据)
mov al, 100H (将高于8位的数据加到8位寄存器中) (一个字节为两个16进制位表示)
```

以上都是错误的指令，错误原因是指令的两个操作对象位数不一致。

3. 8086是16位的CPU，16位结构描述了一个CPU具有以下几个方面的结构特性：	
   - 运算器一次最多可以处理16位数据；
   - 寄存器的最大宽度是16位；
   - 寄存器与运算器之间的通路为16位。

### 8086CPU给出物理地址的方法

8086 cpu有20位地址总线，可以传送20位地址，有1MB的寻址能力。但是CPU是16位结构，因此一次只能处理或者传输16位地址。8086CPU采用一种内部使用两个16位地址合成一个20位物理地址。相关部件的逻辑结构如下图：

![assembly_0003](/images/posts/assembly/assembly_0003.png)

地址加法器采用 ` 物理地址 = 段地址x16 + 偏移地址`的方式合成物理地址。例如想要访问地址123C8H的内存单元，地址加法器的工作流程如下：

![assembly_0004](/images/posts/assembly/assembly_0004.png)

**其本质原因是CPU是16位结构，无法存储20位结构的地址，因此需要两个16位，并约定特定的地址计算方式，生成20位的地址。**

### 段的概念

上文中有提到“段地址”，这个名称中包含了”段“的概念，这可能会使人产生误导，认为内存被划分成一个一个的段，每个段有一个段地址。但其实内存并没有分段，段的划分来自于CPU，8086CPU使用 ` 物理地址 = 段地址x16 + 偏移地址`的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。

### 段寄存器以及CS和IP

8086CPU有四个段寄存器：CS、DS、SS和ES。

CS和IP是最关键的两个寄存器，他们指示了要读取指令的地方。CS为代码段寄存器，IP为指令指针寄存器，**在8086PC机上，任意时刻，设CS寄存器中的内容为M，IP中的内容为N，8086CPU将从内存Mx16 + N单元开始，读取一条指令并执行。**

简言之，**8086机中，任意时刻，CPU将CS：IP指向的内容当做指令执行。**

这里便于理解，举例说明读取和执行指令的流程，如不理解，更详细的流程可以参考书籍第二章2.10小结。

![assembly_0005](/images/posts/assembly/assembly_0005.png)

![assembly_0006](/images/posts/assembly/assembly_0006.png)

![assembly_0007](/images/posts/assembly/assembly_0007.png)

![assembly_0008](/images/posts/assembly/assembly_0008.png)

![assembly_0009](/images/posts/assembly/assembly_0009.png)

![assembly_0010](/images/posts/assembly/assembly_0010.png)

8086CPU的工作流程可以简单描述如下：

1. 从CS:IP指向的内存读取指令，读取的指令进入到指令缓冲器；
2. IP = IP + 所读取指令的长度，从而指向下一条指令；
3. 执行指令。转到步骤1，重复这个过程。

### 修改CS、IP指令

8086CPU的大部分寄存器的值，都可以通过mov指令来改变，**mov指令称为传送指令。**但是mov指令不能用于设置CS和IP的值，原因很简单，因为8086CPU没有提供这样的功能。**能改变CS和IP内容的指令成为转移指令**。这里介绍一个最简单的：**jmp指令**。

如果想同时修改CS和IP的值，可用形如“jmp段地址：偏移地址”的指令完成，如：

jmp 2AE3:3, 执行后：CS = 2AE3H， IP=0003H， CPU将从2AE33H处读取指令。

如果只想修改IP寄存器的内容，可以使用形如“jmp 某一合法寄存器”的指令完成， 如：

jmp ax， 指令执行前： ax = 1000H， CS = 2000H， IP = 0003H

​				 指令执行后： ax = 1000H,    CS = 2000H,    IP = 1000H

“jmp 某一合法寄存器”的指令功能为：用寄存器的值修改IP。jmp ax 在含义上等价于 mov  IP， ax。



## 第三章 寄存器（内存访问）

### DS和[address]

8086CPU中有一个DS寄存器，通常存放要访问的数据的段地址，比如我们要读取10000H单元的内容，可以用如下程序进行：

```assembly
mov bx 1000H
mov ds bx
mov al [0]
```

上面3条指令将10000H(1000:0)中的数据读取到al中。

前面提到过，mov指令可完成两种传送：

1. 将数据直接送入寄存器；
2. 将一个寄存器中的内容送入另一个寄存器。

也可以使用mov指令将一个内存单元中的内容送入到寄存器。此时需要指明内存单元的地址，具体格式为： mov  寄存器名， 内存单元地址。

“[···]” 表示一个内存单元， “[···]” 中的0 表示内存单元的偏移地址。这一点和c语言的数组索引下标一致。只有偏移地址无法定位到一个内存单元，定位内存单元还需要段地址。8086CPU自动取DS寄存器中的数据作为内存单元的段地址。

再来看下如何用mov指令从10000H中读取数据。10000H用段地址和偏移地址表示为1000:0， 我们将段地址1000H放入DS，然后用mov al，[0] 完成传送。

**需要说明的是，在上述代码中，我们使用mov bx 1000H和mov ds bx的方式，其中使用到bx进行中转将1000H送入到寄存器DS，那么我们是否可以使用类似mov ds 1000H的方式直接将1000H送入DS。但现实并非如此，8086CPU不支持直接将数据送入到段寄存器的操作，DS是一个段寄存器，所以mov ds 1000H这条指令非法，不支持这个操作的原因源于硬件设计。**

另外：

mov bx 1000H
mov ds bx
mov  [0] al

这几条指令可以实现将al寄存器中的值传送到1000H的内存单元中。

### 小结

1. 字在内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中；

![assembly_0011](/images/posts/assembly/assembly_0011.png)

2. 用mov指令访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中；
3. [address]表示一个偏移地址为address的内存单元；
4. 在内存与寄存器之间传动字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应；
5. mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令。
6. 可以根据自己的推测在debug中实验指令的新格式。

### CPU提供的栈机制

8086CPU提供入栈和出栈指令，最基本的两个是PUSH(入栈)和POP(出栈)。比如push ax 表示将寄存器ax中的数据送入栈中，pop ax表示从栈顶取出数据送入ax。8086CPU的入栈和出栈操作都是以字为单位进行的。

CPU是如何知道栈顶位置的？ 不禁让我们想起另外一个讨论过的问题， 就是CPU如何知道当前要执行的指令所在的位置？ 我们知道答案，那就是CS、IP中存放着段地址和偏移地址。同样地， 也有相应的寄存器存放栈顶地址。在8086CPU中，有两个寄存器，段寄存器SS和寄存器SP，栈顶的段地址存放在SS中，偏移地址存放在SP中，**任意时刻，SS:SP 指向栈顶元素。**push和pop指令执行时，CPU从SS和SP中得到栈顶的地址。

![assembly_0012](/images/posts/assembly/assembly_0012.png)

从图中可以看出，8086CPU中，入栈时，栈顶从高地址向低地址方向增长。

**我们要十分清楚的是**，push和pop指令与mov指令不同，CPU的mov指令只需要一步操作，就是传送，而push和pop需要两部操作。执行push的时候，cpu两步操作为：先改变SP，再向SS:SP处传送；执行pop的时候两步操作为：先读取SS:SP处数据，再改变SP。

**栈的综述**

1. 8086提供栈操作的机制方案如下：

   在SS、SP中存放栈顶的段地址和偏移地址；

   提供入栈和出栈的指令，他们根据SS：SP指示的地址，按照栈的方式访问内存数据。

2. push指令的执行步骤：1）SP=SP-2； 2）向SS：SP指向的字单元中传送数据。

3. pop指令的执行步骤： 1）从SS：SP指向的字单元中读取数据；2） SP = SP + 2。

4. 任意时刻，SS：SP指向栈顶元素；

5. 8086CPU只记录栈顶，栈空间大小需要我们自己管理。

![assembly_0013](/images/posts/assembly/assembly_0013.png)

![assembly_0014](/images/posts/assembly/assembly_0014.png)

## 第四章 第一个程序

主要讲解源程序，编译，链接等相关知识，以及如何使用debug跟踪编译好的可执行文件。



## 第五章 [BX]和LOOP指令

### [bx]与内存单元的描述

[bx]表示一个内存单元时，它的偏移地址在bx中，比如下边的指令:

`mov ax [bx]`

表示将一个内存单元的内容送入ax，这个内存单元的长度是2字节，存放一个字，偏移地址在bx中，段地址在ds中。

`mov al [bx]`

表示将一个内存单元的内容送入al，这个内存单元的长度是1字节，存放一个字节，偏移地址在bx中，段地址在ds中。

**在汇编源程序中，数据不能以字母开头，所以要在前面加0。**例如，9138h在汇编源程序中可以直接写成“9138h”，而A000h在汇编源程序中要写成“0A000h”。





## 第六章 包含多个段的程序

### 6.3 将数据、代码和栈放入不同的段

用多个段来存取数据、代码和栈，和定义代码段一样的方法来定义多个段，然后在这些段里面定义需要的数据，或者通过定义数据来取得栈空间。通过以下一段程序来详细说明。

![assembly_0015](/images/posts/assembly/assembly_0015.jpg)

![assembly_0016](/images/posts/assembly/assembly_0016.jpg)

下面对程序6.4做出说明。

1. 定义多个段的方法

这点从程序可以明显看出，定义一个段的方法和之前所讲的定义代码段的方法没有区别，只是不同的段要有不同的段名。

2. 对段地址的引用

​	访问一个段中的数据需要通过地址，而地址分为两部分，即段地址和偏移地址。如何指明要访问段中数据的段地址呢？ 在程序中，段名就相当于一个标号，它代表了段地址。所以指令“move ax, data”的含义是将名称为“data”的段的段地址送入ax。一个段中的数据的段地址可由段名代表，偏移地址要看它在段中的位置了。程序中“data”段中的数据“0abch”的地址就是： data:6 。要将他送入到bx，就要用到以下代码：

```assembly
mov ax, data
mov ds, ax
mov bx, ds:[6]
```

我们不能使用下面的指令：

mov ds, data

move bx, ds:[6]

其中“mov ds, data”是错误的，因为8086CPU不允许将一个数值直接送入段寄存器。程序中对段名的引用，如指令“mov ds, data”中的data，将被编译器处理为一个表示段地址的数值。

3. “代码段”、“数据段”、“栈段”完全是我们的安排

​	现在我们以一个具体的程序再次讨论一下所谓的“代码段”、“数据段”、“栈段”。在汇编程序中，可以定义许多的段，比如程序6.4中定义了三个段，“code”，“data”和“stack”。我们可以分别安排他们存放代码、数据和栈。那么我们如何让CPU按照我们的安排执行这个程序呢？ 来看看源程序对3个段所做的处理。

- 我们在源程序中将用来存放数据的段命名为“data”, 放代码的段叫“code”， 用作栈空间的段命名“stack”，如此命名之后，CPU是否就会去执行“code”段中的内容，处理“data”段中的数据，然后将”stack“当做栈了呢？****

​		当然不是，我们这样命名只是为了使程序便于阅读，类似命名的段还有很多，CPU并不知道他们。

- 我们在源程序中用伪指令“assume cs:code, ds:data, ss:stack”将cs，ds和ss分别和code、data、stack段相连。这样之后，CPU是都就会将cs指向code，ds指向data，ss指向stack，从未按照我们的意图去处理这些段呢？ 

​		当然也不是，要知道assume是伪指令 ，有编译器执行，也是仅在源程序中存在的信息，CPU并不知道它们。

- 若要CPU按照我们的安排行事，需要用机器指令控制它，源程序中汇编指令是CPU要执行的内容。CPU如何知道去执行它们？ 我们在源程序最后用“end start”说明了程序的入口，这个入口将被写入可执行文件的描述信息，可执行文件中的程序被加载入内存之后，CPU的CS：IP被设置指向这个入口，从而开始执行程序中的第一条指令。标号“start”在“code”段中，这样CPU就将code段中的内容当做指令来执行了。我们在code段中使用指令：	

```assembly
mov ax, stack
mov ss, ax 
mov sp, 20h
```

设置ss指向stack，设置ss指向stack:20, CPU执行这些指令后，将把stack当做栈空间来用，CPU若要访问data段中的数据，可用ds指向data段，用其他寄存器（如bx）来存放data段中数据的偏移地址。

**总之，CPU如何处理我们定义段中的内容，是当做指令执行，当做数据访问，还是当做栈空间，完全是靠程序中具体的汇编指令，和汇编指令对CS:IP, SS:SP，DS等寄存器的设置来决定的。**

完全可以将程序6.4改写成下面的样子实现，相同的功能。

![assembly_0017](/images/posts/assembly/assembly_0017.jpg)


## 参考

- 《汇编语言》 王爽